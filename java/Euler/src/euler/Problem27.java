package euler;

import java.util.TreeSet;

public class Problem27 extends utils.CAN {

	TreeSet<Integer> set;
	public  void _findAllPrimesLess(int upperBound) {

			set =new TreeSet<Integer>();
		    int upperBoundSquareRoot = (int) java.lang.Math.sqrt(upperBound);

		    boolean[] isComposite = new boolean[upperBound + 1];

		    for (int m = 2; m <= upperBoundSquareRoot; m++) {

		          if (!isComposite[m]) {

		                set.add(m);

		                for (int k = m * m; k <= upperBound; k += m)

		                      isComposite[k] = true;

		          }

		    }

		    for (int m = upperBoundSquareRoot; m <= upperBound; m++)

		          if (!isComposite[m])

		                set.add(m);

		
		
		
		
		
	}
	
	
	public  void calc() {
		int nbest=0,abest=-1,bbest=-1;
		_findAllPrimesLess(1000);
		for(int b:set) {  //b must be prime ,because for n=0 =>b
			for(int a=-999; a<1000; a++) {
				int n;
				for(n=1; ; n++) {
					int f=n*n+a*n+b;
					if(f<=1)break; //if the result is negative stop
					if(f<1000) {
						if(!set.contains(f))break; ///if f:prime and f<1000 ,must be in the set
					}
					else if(!isPrime(f))break;
					
				}
				if(n-1>nbest) {
					nbest=n-1;
					abest=a;
					bbest=b;
				}
			}
			
			
		}
		
		print("a="+abest+" b="+bbest+" n="+nbest);
	}
	
	
	
	
	public static void main(String[] args) {
		new Problem27().calc();
	}

}

/*
 * the maximum number of solutions is limited by the 
 * constant, b: n2+an+b. 
 * When n=b, we get b2+ab+b, which is clearly divisible 
 * by b and is composite. The same is true for n=kb, 
 * so there can never be more than b-1 consecutive primes.
 * 
 * I did not use a computer to solve this problem. 
 * The formula n^2-79n+1601 is nothing more than 
 * (n-40)^2+n-40+41 so that all the forty primes 
 * of n^2+n+41 are met twice that's why 80 primes 
 * are found, but only 40 different one's. So what 
 * I did was: take (n-p)^2+n-p+41, working out this 
 * formula gives: n^2-(2p-1)n+p^2-p+41. Now |2p-1|<1000 
 * and |p^2-p+41|<1000. The second condition gives 
 * -30<=p<=31 The value p=31 gives the most primes.
 *  So the numbers are -(2*31-1)=-61 and 31^2-31+41=971.
 * 
 * Like you, hk, I didn't write a program to solve this
 *  one. I was helped by looking at the primes 
 *  generated by the two examples and finding they 
 *  contained the same numbers! The second differences
 *   in every quadratic case, irrespective of the 
 *   values of a or b, must be 2: 41 43 47 53 61 71 ... 1st 
 *   difference 2 4 6 8 10 ... 2nd 
 *   difference 2 2 2 2 ... 
 *   This suggested to me that the sequence beginning at 
 *   41 was very special, something I verified by applying
 *    these differences to larger primes and generating only
 *     very short strings of primes. So I deduced that the
 *      answer must use the same sequence, reducing from 
 *      the prime in the sequence which is the greatest 
 *      below 1000, i.e. 971, as this becomes b (which must
 *       be less than 1000).
 * 
 * 
 */
